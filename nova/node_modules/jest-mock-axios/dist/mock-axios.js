"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jestMockPromise = _interopRequireDefault(require("jest-mock-promise"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * TypeScript version of Axios mock for unit testing with [Jest](https://facebook.github.io/jest/).
 * This file is based on https://gist.github.com/tux4/36006a1859323f779ab0
 *
 * @author   knee-cola <nikola.derezic@gmail.com>
 * @license  @license MIT License, http://www.opensource.org/licenses/MIT
 */

/** a FIFO queue of pending request */
var _pending_requests = [];

var _newReq = function _newReq(url, data, config) {
  var promise = new _jestMockPromise["default"]();

  _pending_requests.push({
    config: config,
    data: data,
    promise: promise,
    url: url
  });

  return promise;
};

var MockAxios = jest.fn(_newReq); // mocking Axios methods

MockAxios.get = jest.fn(_newReq);
MockAxios.post = jest.fn(_newReq);
MockAxios.put = jest.fn(_newReq);
MockAxios.patch = jest.fn(_newReq);
MockAxios["delete"] = jest.fn(_newReq);
MockAxios.all = jest.fn(function (values) {
  return Promise.all(values);
});
MockAxios.head = jest.fn(_newReq);
MockAxios.options = jest.fn(_newReq);
MockAxios.create = jest.fn(function () {
  return MockAxios;
});
MockAxios.interceptors = {
  request: {
    use: jest.fn()
  },
  response: {
    use: jest.fn()
  }
};
MockAxios.defaults = {
  headers: {
    common: []
  }
};

MockAxios.popPromise = function (promise) {
  if (promise) {
    // remove the promise from pending queue
    for (var ix = 0; ix < _pending_requests.length; ix++) {
      var req = _pending_requests[ix];

      if (req.promise === promise) {
        _pending_requests.splice(ix, 1);

        return req.promise;
      }
    }
  } else {
    // take the oldest promise
    var _req = _pending_requests.shift();

    return _req ? _req.promise : void 0;
  }
};

MockAxios.popRequest = function (request) {
  if (request) {
    var ix = _pending_requests.indexOf(request);

    if (ix === -1) {
      return void 0;
    }

    _pending_requests.splice(ix, 1);

    return request;
  } else {
    return _pending_requests.shift();
  }
};
/**
 * Removes an item form the queue, based on it's type
 * @param queueItem
 */


var popQueueItem = function popQueueItem() {
  var queueItem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  // first le't pretend the param is a queue item
  var request = MockAxios.popRequest(queueItem);

  if (request) {
    // IF the request was found
    return request.promise;
  } else {
    // ELSE maybe the `queueItem` is a promise (legacy mode)
    return MockAxios.popPromise(queueItem);
  }
};

MockAxios.mockResponse = function (response) {
  var queueItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var silentMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // replacing missing data with default values
  response = Object.assign({
    config: {},
    data: {},
    headers: {},
    status: 200,
    statusText: "OK"
  }, response);
  var promise = popQueueItem(queueItem);

  if (!promise && !silentMode) {
    throw new Error('No request to respond to!');
  } else if (!promise) {
    return;
  } // resolving the Promise with the given response data


  promise.resolve(response);
};

MockAxios.mockError = function () {
  var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var queueItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var silentMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var promise = popQueueItem(queueItem);

  if (!promise && !silentMode) {
    throw new Error('No request to respond to!');
  } else if (!promise) {
    return;
  } // resolving the Promise with the given response data


  promise.reject(Object.assign({}, error));
};

MockAxios.lastReqGet = function () {
  return _pending_requests[_pending_requests.length - 1];
};

MockAxios.lastPromiseGet = function () {
  var req = MockAxios.lastReqGet();
  return req ? req.promise : void 0;
};

MockAxios.reset = function () {
  // remove all the requests
  _pending_requests.splice(0, _pending_requests.length); // resets all information stored in the mockFn.mock.calls and mockFn.mock.instances arrays


  MockAxios.get.mockClear();
  MockAxios.post.mockClear();
  MockAxios.put.mockClear();
  MockAxios.patch.mockClear();
  MockAxios["delete"].mockClear();
  MockAxios.head.mockClear();
  MockAxios.options.mockClear();
  MockAxios.all.mockClear();
}; // this is a singleton object


var _default = MockAxios;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2xpYi9tb2NrLWF4aW9zLnRzIl0sIm5hbWVzIjpbIl9wZW5kaW5nX3JlcXVlc3RzIiwiX25ld1JlcSIsInVybCIsImRhdGEiLCJjb25maWciLCJwcm9taXNlIiwiU3luY1Byb21pc2UiLCJwdXNoIiwiTW9ja0F4aW9zIiwiamVzdCIsImZuIiwiZ2V0IiwicG9zdCIsInB1dCIsInBhdGNoIiwiYWxsIiwidmFsdWVzIiwiUHJvbWlzZSIsImhlYWQiLCJvcHRpb25zIiwiY3JlYXRlIiwiaW50ZXJjZXB0b3JzIiwicmVxdWVzdCIsInVzZSIsInJlc3BvbnNlIiwiZGVmYXVsdHMiLCJoZWFkZXJzIiwiY29tbW9uIiwicG9wUHJvbWlzZSIsIml4IiwibGVuZ3RoIiwicmVxIiwic3BsaWNlIiwic2hpZnQiLCJwb3BSZXF1ZXN0IiwiaW5kZXhPZiIsInBvcFF1ZXVlSXRlbSIsInF1ZXVlSXRlbSIsIm1vY2tSZXNwb25zZSIsInNpbGVudE1vZGUiLCJPYmplY3QiLCJhc3NpZ24iLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiRXJyb3IiLCJyZXNvbHZlIiwibW9ja0Vycm9yIiwiZXJyb3IiLCJyZWplY3QiLCJsYXN0UmVxR2V0IiwibGFzdFByb21pc2VHZXQiLCJyZXNldCIsIm1vY2tDbGVhciJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVFBOzs7O0FBUkE7Ozs7Ozs7O0FBV0E7QUFDQSxJQUFNQSxpQkFBdUMsR0FBRyxFQUFoRDs7QUFFQSxJQUFNQyxPQUErRCxHQUFHLFNBQWxFQSxPQUFrRSxDQUFDQyxHQUFELEVBQWNDLElBQWQsRUFBMEJDLE1BQTFCLEVBQTJDO0FBQ2pILE1BQU1DLE9BQW9CLEdBQUcsSUFBSUMsMkJBQUosRUFBN0I7O0FBQ0FOLEVBQUFBLGlCQUFpQixDQUFDTyxJQUFsQixDQUF1QjtBQUNyQkgsSUFBQUEsTUFBTSxFQUFOQSxNQURxQjtBQUVyQkQsSUFBQUEsSUFBSSxFQUFKQSxJQUZxQjtBQUdyQkUsSUFBQUEsT0FBTyxFQUFQQSxPQUhxQjtB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d0MsU0FBZjtBQUNBNUMsRUFBQUEsU0FBUyxDQUFDSyxHQUFWLENBQWN1QyxTQUFkO0FBQ0E1QyxFQUFBQSxTQUFTLENBQUNNLEtBQVYsQ0FBZ0JzQyxTQUFoQjtBQUNBNUMsRUFBQUEsU0FBUyxVQUFULENBQWlCNEMsU0FBakI7QUFDQTVDLEVBQUFBLFNBQVMsQ0FBQ1UsSUFBVixDQUFla0MsU0FBZjtBQUNBNUMsRUFBQUEsU0FBUyxDQUFDVyxPQUFWLENBQWtCaUMsU0FBbEI7QUFDQTVDLEVBQUFBLFNBQVMsQ0FBQ08sR0FBVixDQUFjcUMsU0FBZDtBQUNELENBYkQsQyxDQWVBOzs7ZUFDZTVDLFMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogVHlwZVNjcmlwdCB2ZXJzaW9uIG9mIEF4aW9zIG1vY2sgZm9yIHVuaXQgdGVzdGluZyB3aXRoIFtKZXN0XShodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9qZXN0LykuXHJcbiAqIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS90dXg0LzM2MDA2YTE4NTkzMjNmNzc5YWIwXHJcbiAqXHJcbiAqIEBhdXRob3IgICBrbmVlLWNvbGEgPG5pa29sYS5kZXJlemljQGdtYWlsLmNvbT5cclxuICogQGxpY2Vuc2UgIEBsaWNlbnNlIE1JVCBMaWNlbnNlLCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxyXG4gKi9cclxuXHJcbmltcG9ydCBTeW5jUHJvbWlzZSBmcm9tIFwiamVzdC1tb2NrLXByb21pc2VcIjtcclxuaW1wb3J0IHsgQW55RnVuY3Rpb24sIEF4aW9zTW9ja1F1ZXVlSXRlbSwgQXhpb3NNb2NrVHlwZSwgSHR0cFJlc3BvbnNlLCBTcHlGbiB9IGZyb20gXCIuL21vY2stYXhpb3MtdHlwZXNcIjtcclxuXHJcbi8qKiBhIEZJRk8gcXVldWUgb2YgcGVuZGluZyByZXF1ZXN0ICovXHJcbmNvbnN0IF9wZW5kaW5nX3JlcXVlc3RzOiBBeGlvc01vY2tRdWV1ZUl0ZW1bXSA9IFtdO1xyXG5cclxuY29uc3QgX25ld1JlcTogKHVybDogc3RyaW5nLCBkYXRhPzogYW55LCBjb25maWc/OiBhbnkpID0+IFN5bmNQcm9taXNlID0gKHVybDogc3RyaW5nLCBkYXRhPzogYW55LCBjb25maWc/OiBhbnkpID0+IHtcclxuICBjb25zdCBwcm9taXNlOiBTeW5jUHJvbWlzZSA9IG5ldyBTeW5jUHJvbWlzZSgpO1xyXG4gIF9wZW5kaW5nX3JlcXVlc3RzLnB1c2goe1xyXG4gICAgY29uZmlnLFxyXG4gICAgZGF0YSxcclxuICAgIHByb21pc2UsXHJcbiAgICB1cmwsXHJcbiAgfSk7XHJcbiAgcmV0dXJuKHByb21pc2UpO1xyXG59O1xyXG5cclxuY29uc3QgTW9ja0F4aW9zOiBBeGlvc01vY2tUeXBlID0gamVzdC5mbihfbmV3UmVxKSBhcyB1bmtub3duIGFzIEF4aW9zTW9ja1R5cGU7XHJcblxyXG4vLyBtb2NraW5nIEF4aW9zIG1ldGhvZHNcclxuTW9ja0F4aW9zLmdldCA9IGplc3QuZm4oX25ld1JlcSk7XHJcbk1vY2tBeGlvcy5wb3N0ID0gamVzdC5mbihfbmV3UmVxKTtcclxuTW9ja0F4aW9zLnB1dCA9IGplc3QuZm4oX25ld1JlcSk7XHJcbk1vY2tBeGlvcy5wYXRjaCA9IGplc3QuZm4oX25ld1JlcSk7XHJcbk1vY2tBeGlvcy5kZWxldGUgPSBqZXN0LmZuKF9uZXdSZXEpO1xyXG5Nb2NrQXhpb3MuYWxsID0gamVzdC5mbigodmFsdWVzKSA9PiBQcm9taXNlLmFsbCh2YWx1ZXMpKTtcclxuTW9ja0F4aW9zLmhlYWQgPSBqZXN0LmZuKF9uZXdSZXEpO1xyXG5Nb2NrQXhpb3Mub3B0aW9ucyA9IGplc3QuZm4oX25ld1JlcSk7XHJcbk1vY2tBeGlvcy5jcmVhdGUgPSBqZXN0LmZuKCgpID0+IE1vY2tBeGlvcyk7XHJcblxyXG5Nb2NrQXhpb3MuaW50ZXJjZXB0b3JzID0ge1xyXG4gIHJlcXVlc3Q6IHtcclxuICAgIHVzZTogamVzdC5mbigpXHJcbiAgfSxcclxuICByZXNwb25zZToge1xyXG4gICAgdXNlOiBqZXN0LmZuKClcclxuICB9XHJcbn07XHJcblxyXG5Nb2NrQXhpb3MuZGVmYXVsdHMgPSB7XHJcbiAgaGVhZGVyczoge1xyXG4gICAgY29tbW9uOiBbXVxyXG4gIH1cclxufVxyXG5cclxuTW9ja0F4aW9zLnBvcFByb21pc2UgPSAocHJvbWlzZT86IFN5bmNQcm9taXNlKSA9PiB7XHJcblxyXG4gIGlmIChwcm9taXNlKSB7XHJcbiAgICAvLyByZW1vdmUgdGhlIHByb21pc2UgZnJvbSBwZW5kaW5nIHF1ZXVlXHJcbiAgICBmb3IgKGxldCBpeCA9IDA7IGl4IDwgX3BlbmRpbmdfcmVxdWVzdHMubGVuZ3RoOyBpeCsrKSB7XHJcblxyXG4gICAgICBjb25zdCByZXE6IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IF9wZW5kaW5nX3JlcXVlc3RzW2l4XTtcclxuXHJcbiAgICAgIGlmIChyZXEucHJvbWlzZSA9PT0gcHJvbWlzZSkge1xyXG4gICAgICAgIF9wZW5kaW5nX3JlcXVlc3RzLnNwbGljZShpeCwgMSk7XHJcbiAgICAgICAgcmV0dXJuKHJlcS5wcm9taXNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gdGFrZSB0aGUgb2xkZXN0IHByb21pc2VcclxuICAgIGNvbnN0IHJlcTogQXhpb3NNb2NrUXVldWVJdGVtID0gX3BlbmRpbmdfcmVxdWVzdHMuc2hpZnQoKTtcclxuICAgIHJldHVybihyZXEgPyByZXEucHJvbWlzZSA6IHZvaWQgMCk7XHJcbiAgfVxyXG59O1xyXG5cclxuTW9ja0F4aW9zLnBvcFJlcXVlc3QgPSAocmVxdWVzdD86IEF4aW9zTW9ja1F1ZXVlSXRlbSkgPT4ge1xyXG5cclxuICBpZiAocmVxdWVzdCkge1xyXG4gICAgY29uc3QgaXggPSBfcGVuZGluZ19yZXF1ZXN0cy5pbmRleE9mKHJlcXVlc3QpO1xyXG4gICAgaWYgKGl4ID09PSAtMSkge1xyXG4gICAgICByZXR1cm4odm9pZCAwKTtcclxuICAgIH1cclxuXHJcbiAgICBfcGVuZGluZ19yZXF1ZXN0cy5zcGxpY2UoaXgsIDEpO1xyXG4gICAgcmV0dXJuKHJlcXVlc3QpO1xyXG5cclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuKF9wZW5kaW5nX3JlcXVlc3RzLnNoaWZ0KCkpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFuIGl0ZW0gZm9ybSB0aGUgcXVldWUsIGJhc2VkIG9uIGl0J3MgdHlwZVxyXG4gKiBAcGFyYW0gcXVldWVJdGVtXHJcbiAqL1xyXG5jb25zdCBwb3BRdWV1ZUl0ZW0gPSAocXVldWVJdGVtOiBTeW5jUHJvbWlzZXxBeGlvc01vY2tRdWV1ZUl0ZW09IG51bGwpID0+IHtcclxuICAvLyBmaXJzdCBsZSd0IHByZXRlbmQgdGhlIHBhcmFtIGlzIGEgcXVldWUgaXRlbVxyXG4gIGNvbnN0IHJlcXVlc3Q6IEF4aW9zTW9ja1F1ZXVlSXRlbSA9IE1vY2tBeGlvcy5wb3BSZXF1ZXN0KHF1ZXVlSXRlbSBhcyBBeGlvc01vY2tRdWV1ZUl0ZW0pO1xyXG5cclxuICBpZiAocmVxdWVzdCkge1xyXG4gIC8vIElGIHRoZSByZXF1ZXN0IHdhcyBmb3VuZFxyXG4gIC8vID4gc2V0IHRoZSBwcm9taXNlXHJcbiAgICByZXR1cm4ocmVxdWVzdC5wcm9taXNlKTtcclxuICB9IGVsc2Uge1xyXG4gIC8vIEVMU0UgbWF5YmUgdGhlIGBxdWV1ZUl0ZW1gIGlzIGEgcHJvbWlzZSAobGVnYWN5IG1vZGUpXHJcbiAgICByZXR1cm4oTW9ja0F4aW9zLnBvcFByb21pc2UocXVldWVJdGVtIGFzIFN5bmNQcm9taXNlKSk7XHJcbiAgfVxyXG59O1xyXG5cclxuTW9ja0F4aW9zLm1vY2tSZXNwb25zZSA9IChyZXNwb25zZT86IEh0dHBSZXNwb25zZSwgcXVldWVJdGVtOiBTeW5jUHJvbWlzZXxBeGlvc01vY2tRdWV1ZUl0ZW09IG51bGwsIHNpbGVudE1vZGU6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQgPT4ge1xyXG5cclxuICAvLyByZXBsYWNpbmcgbWlzc2luZyBkYXRhIHdpdGggZGVmYXVsdCB2YWx1ZXNcclxuICByZXNwb25zZSA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgY29uZmlnOiB7fSxcclxuICAgIGRhdGE6IHt9LFxyXG4gICAgaGVhZGVyczoge30sXHJcbiAgICBzdGF0dXM6IDIwMCxcclxuICAgIHN0YXR1c1RleHQ6IFwiT0tcIixcclxuICB9LCByZXNwb25zZSk7XHJcblxyXG4gIGNvbnN0IHByb21pc2UgPSBwb3BRdWV1ZUl0ZW0ocXVldWVJdGVtKTtcclxuXHJcbiAgaWYoIXByb21pc2UgJiYgIXNpbGVudE1vZGUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVxdWVzdCB0byByZXNwb25kIHRvIScpXHJcbiAgfSBlbHNlIGlmKCFwcm9taXNlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyByZXNvbHZpbmcgdGhlIFByb21pc2Ugd2l0aCB0aGUgZ2l2ZW4gcmVzcG9uc2UgZGF0YVxyXG4gIHByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XHJcbn07XHJcblxyXG5Nb2NrQXhpb3MubW9ja0Vycm9yID0gKGVycm9yOiBhbnk9IHt9LCBxdWV1ZUl0ZW06IFN5bmNQcm9taXNlfEF4aW9zTW9ja1F1ZXVlSXRlbT0gbnVsbCwgc2lsZW50TW9kZTogYm9vbGVhbiA9IGZhbHNlKSA9PiB7XHJcbiAgY29uc3QgcHJvbWlzZSA9IHBvcFF1ZXVlSXRlbShxdWV1ZUl0ZW0pO1xyXG5cclxuICBpZighcHJvbWlzZSAmJiAhc2lsZW50TW9kZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXF1ZXN0IHRvIHJlc3BvbmQgdG8hJylcclxuICB9IGVsc2UgaWYoIXByb21pc2UpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIHJlc29sdmluZyB0aGUgUHJvbWlzZSB3aXRoIHRoZSBnaXZlbiByZXNwb25zZSBkYXRhXHJcbiAgcHJvbWlzZS5yZWplY3QoT2JqZWN0LmFzc2lnbih7fSwgZXJyb3IpKTtcclxufTtcclxuXHJcbk1vY2tBeGlvcy5sYXN0UmVxR2V0ID0gKCkgPT4ge1xyXG4gIHJldHVybihfcGVuZGluZ19yZXF1ZXN0c1tfcGVuZGluZ19yZXF1ZXN0cy5sZW5ndGggLSAxXSk7XHJcbn07XHJcblxyXG5Nb2NrQXhpb3MubGFzdFByb21pc2VHZXQgPSAoKSA9PiB7XHJcbiAgY29uc3QgcmVxID0gTW9ja0F4aW9zLmxhc3RSZXFHZXQoKTtcclxuICByZXR1cm4ocmVxID8gcmVxLnByb21pc2UgOiB2b2lkIDApO1xyXG59O1xyXG5cclxuTW9ja0F4aW9zLnJlc2V0ID0gKCkgPT4ge1xyXG4gIC8vIHJlbW92ZSBhbGwgdGhlIHJlcXVlc3RzXHJcbiAgX3BlbmRpbmdfcmVxdWVzdHMuc3BsaWNlKDAsIF9wZW5kaW5nX3JlcXVlc3RzLmxlbmd0aCk7XHJcblxyXG4gIC8vIHJlc2V0cyBhbGwgaW5mb3JtYXRpb24gc3RvcmVkIGluIHRoZSBtb2NrRm4ubW9jay5jYWxscyBhbmQgbW9ja0ZuLm1vY2suaW5zdGFuY2VzIGFycmF5c1xyXG4gIE1vY2tBeGlvcy5nZXQubW9ja0NsZWFyKCk7XHJcbiAgTW9ja0F4aW9zLnBvc3QubW9ja0NsZWFyKCk7XHJcbiAgTW9ja0F4aW9zLnB1dC5tb2NrQ2xlYXIoKTtcclxuICBNb2NrQXhpb3MucGF0Y2gubW9ja0NsZWFyKCk7XHJcbiAgTW9ja0F4aW9zLmRlbGV0ZS5tb2NrQ2xlYXIoKTtcclxuICBNb2NrQXhpb3MuaGVhZC5tb2NrQ2xlYXIoKTtcclxuICBNb2NrQXhpb3Mub3B0aW9ucy5tb2NrQ2xlYXIoKTtcclxuICBNb2NrQXhpb3MuYWxsLm1vY2tDbGVhcigpO1xyXG59O1xyXG5cclxuLy8gdGhpcyBpcyBhIHNpbmdsZXRvbiBvYmplY3RcclxuZXhwb3J0IGRlZmF1bHQgTW9ja0F4aW9zO1xyXG4iXX0=